# 듀얼칩 설계 전략 및 펌웨어 업그레이드 방법

> DeepCo_Dual (ESP32-S3 + RTL8720DN) 보드의 USB-C 포트 연결 전략과
> 각 전략별 펌웨어 업그레이드 방법을 정리한 문서입니다.

---

## 1. 설계 전략 비교

### 1.1 전제 조건

- 보드에 **USB-C 포트 1개**만 존재
- 용도: **5V 전원 공급** + **시리얼 통신** (펌웨어 플래시 / 디버그 로그)
- 칩 간 연결: UART (제어 명령) + SPI (카메라 JPEG)
- 목표: 하나의 USB-C로 개발/디버그/OTA를 최대한 커버

---

### 1.2 옵션 A: USB-C → RTL8720DN

```
[USB-C] ── RTL8720DN ──UART──> ESP32-S3
               │                   │
          Wi-Fi AP              카메라/모터
          WS 서버               SPI Slave
          USB Serial
```

| 장점 | 단점 |
|------|------|
| 네트워크(Wi-Fi/WS) 로그를 USB에서 직접 확인 | S3 펌웨어 플래시에 RTL 경유 필요 |
| RTL 펌웨어 USB 직접 업로드 가능 | S3 저수준 디버그(crash dump) 직접 확인 불가 |
| S3 로그 중계(`@log,`) 이미 구현됨 | S3 부트모드 진입에 추가 GPIO 2개 필요 |
| `@set,channel` 등 RTL 설정 명령 바로 입력 가능 | RTL이 죽으면 USB 통신 자체 불가 (단일 실패점) |
| **현재 코드와 100% 호환** | — |

---

### 1.3 옵션 B: USB-C → ESP32-S3

```
           RTL8720DN ──UART──> ESP32-S3 ── [USB-C]
              │                    │
         Wi-Fi AP              카메라/모터
         WS 서버               USB Serial
                               SPI Slave
```

| 장점 | 단점 |
|------|------|
| S3 펌웨어를 Arduino IDE / esptool로 직접 업로드 | RTL 펌웨어 플래시에 S3 경유 필요 |
| S3 crash dump, stack trace 직접 확인 | RTL 디버그 로그를 보려면 중계 코드 추가 필요 |
| ESP32-S3 USB-OTG 활용 가능 (향후 확장) | 현재 코드 구조 리팩토링 필요 |
| 자동 부트모드 진입 (DTR/RTS) 지원 | RTL `@set,channel` 등 명령이 S3 경유 |
| 모터/카메라/LED 상태 USB에서 바로 확인 | Wi-Fi 문제 디버깅 시 RTL 로그 간접 확인 |

---

### 1.4 옵션 C: USB-C → USB 허브 → 양쪽 모두

```
[USB-C] ── USB Hub IC ┬── RTL8720DN
                      └── ESP32-S3
```

| 장점 | 단점 |
|------|------|
| 양쪽 모두 직접 플래시/디버그 가능 | USB 허브 IC 추가 (보드 복잡도/비용 증가) |
| PC에서 두 개의 COM 포트로 인식 | 보드 면적 증가, 소형화 불리 |
| 가장 유연한 개발 환경 | BOM 비용 상승 |

---

### 1.5 옵션 D: USB-C → S3 + S3가 RTL 플래시 대행 (하이브리드)

```
[USB-C] ── ESP32-S3 ──UART──> RTL8720DN
               │
          GPIO로 RTL의 BOOT/RESET 제어
```

| 장점 | 단점 |
|------|------|
| S3 플래시: USB 직접 (표준 ESP32 방식) | S3에 RTL 플래시 에이전트 코드 구현 필요 |
| RTL 플래시: S3 경유 UART 부트로더 | 개발 초기에는 RTL 별도 플래시 필요 |
| 하나의 USB-C로 양쪽 모두 플래시 가능 | RTL 디버그 로그는 S3 경유 간접 확인 |
| 보드 추가 비용 최소 (GPIO 2개만 추가) | — |
| ESP32-S3 USB-OTG 활용 가능 | — |

---

### 1.6 옵션 E: USB-C → RTL + RTL이 S3 플래시 대행 (RTL 하이브리드)

```
[USB-C] ── RTL8720DN ──UART──> ESP32-S3
               │                   │
          Wi-Fi AP              카메라/모터
          WS 서버               SPI Slave
          USB Serial
          GPIO로 S3의 BOOT/EN 제어
```

> 옵션 A의 확장판. USB-C는 RTL에 연결하되, RTL이 GPIO 2개로 S3의 부트모드/리셋을
> 제어하여 패스스루 플래시도 가능하게 한 구조.

| 장점 | 단점 |
|------|------|
| RTL 펌웨어 USB 직접 업로드 (표준 AmebaD 방식) | S3 디버그(crash dump, stack trace) 간접 확인 |
| S3 플래시: RTL 패스스루 → UART → S3 (GPIO로 부트모드 진입) | S3 USB-OTG 활용 불가 |
| 하나의 USB-C로 양쪽 모두 플래시 가능 | RTL이 죽으면 USB 통신 자체 불가 (단일 실패점) |
| **현재 코드 구조 100% 호환** (USB가 RTL 측) | RTL→S3 패스스루 시 esptool 프로토콜 중계 구현 필요 |
| Wi-Fi/WS 네트워크 로그를 USB에서 직접 확인 | — |
| `@set,channel` 등 RTL 설정 명령 바로 입력 가능 | — |
| 보드 비용 최소 (GPIO 2개만 추가) | — |
| Wi-Fi OTA로 양쪽 모두 커버 가능 | — |

**필요 추가 배선 (GPIO 2개):**

```
RTL8720DN GPIO_X ──→ ESP32-S3 GPIO0 (BOOT)
RTL8720DN GPIO_Y ──→ ESP32-S3 EN   (RESET)
```

**옵션 D (S3 하이브리드) vs 옵션 E (RTL 하이브리드) 핵심 차이:**

| 비교 항목 | D: S3 하이브리드 | E: RTL 하이브리드 |
|-----------|:---:|:---:|
| USB 직접 연결 칩 | S3 | RTL |
| 직접 디버그 대상 | S3 (모터/카메라/LED) | RTL (Wi-Fi/WS/네트워크) |
| USB-OTG 확장 | ★ 가능 | — 불가 |
| 현재 코드 호환 | ○ 일부 수정 | ★ 그대로 |
| 패스스루로 플래시하는 칩 | RTL (S3가 중계) | S3 (RTL이 중계) |
| GPIO 제어 방향 | S3 → RTL BOOT/EN | RTL → S3 BOOT/EN |

---

### 1.7 종합 비교표

| 기준 | A: USB→RTL | B: USB→S3 | C: 허브 | D: S3 하이브리드 | E: RTL 하이브리드 |
|------|:---:|:---:|:---:|:---:|:---:|
| S3 플래시 용이성 | ▲ 어려움 | ★ 쉬움 | ★ 쉬움 | ★ 쉬움 | ○ 중간 (패스스루) |
| RTL 플래시 용이성 | ★ 쉬움 | ▲ 어려움 | ★ 쉬움 | ○ 중간 (패스스루) | ★ 쉬움 |
| S3 디버그 | ○ 간접 | ★ 직접 | ★ 직접 | ★ 직접 | ○ 간접 |
| RTL 디버그 | ★ 직접 | ○ 간접 | ★ 직접 | ○ 간접 | ★ 직접 |
| 현재 코드 호환 | ★ 그대로 | ▲ 리팩토링 | ○ 양쪽 수정 | ○ 일부 수정 | ★ 그대로 |
| 보드 비용 | ★ 낮음 | ★ 낮음 | ▲ 높음 | ★ 낮음 | ★ 낮음 |
| OTA 친화도 | ○ RTL 유리 | ○ S3 유리 | ★ 양쪽 | ★ 양쪽 | ★ 양쪽 |
| 향후 확장성 | ○ 보통 | ★ USB-OTG | ★ 높음 | ★ USB-OTG | ○ 보통 |
| 추가 하드웨어 | 없음 | 없음 | 허브 IC | GPIO 2개 | GPIO 2개 |
| 단일 실패점 | RTL | S3 | 없음 | S3 | RTL |

> ★ 우수 / ○ 보통 / ▲ 부족

---

## 2. 옵션별 펌웨어 업그레이드 방법

### 2.1 옵션 A (USB→RTL) 의 펌웨어 업그레이드

#### RTL 펌웨어 업그레이드

| 방법 | 설명 |
|------|------|
| **USB 직접 플래시** | Arduino IDE에서 AmebaD 보드 선택 → USB-C 연결 → Upload. 가장 단순하고 표준적인 방법. |
| **Wi-Fi OTA** | RTL이 HTTP `/ota` 엔드포인트를 제공 → PC에서 `.bin` 업로드 → Flash OTA 파티션에 기록 → 재부팅. AmebaD SDK OTA 지원 활용. |

#### S3 펌웨어 업그레이드

| 방법 | 필요 조건 | 설명 |
|------|-----------|------|
| **UART 부트로더 경유** | RTL에서 S3의 GPIO0 + EN 제어 (GPIO 2개 추가 배선) | RTL이 S3를 부트모드로 전환 → UART로 esptool 프로토콜 실행 → 플래시 완료 후 정상 부팅. PC에서 RTL을 "패스스루" 모드로 전환하여 esptool이 RTL의 USB-UART를 통해 S3에 직접 통신. |
| **UART OTA (S3 자체)** | S3 펌웨어에 OTA 수신 코드 내장 + OTA 파티션 | RTL이 PC에서 받은 `.bin`을 UART로 S3에 청크 전달 (`@ota,start` / `@ota,data` / `@ota,end`). S3가 `Update.h`로 OTA 파티션에 기록 → 검증 → 재부팅. 추가 배선 불필요하지만 S3 펌웨어에 OTA 코드가 있어야 함. |
| **Wi-Fi → RTL → UART → S3** | 위 UART OTA + RTL HTTP OTA 엔드포인트 | PC → Wi-Fi → RTL HTTP → UART → S3 OTA. 완전 무선. |

---

### 2.2 옵션 B (USB→S3) 의 펌웨어 업그레이드

#### S3 펌웨어 업그레이드

| 방법 | 설명 |
|------|------|
| **USB 직접 플래시** | Arduino IDE에서 ESP32-S3 보드 선택 → USB-C 연결 → Upload. 자동 부트모드 진입(DTR/RTS). 가장 단순. |
| **Wi-Fi OTA (RTL 경유)** | PC → Wi-Fi → RTL WS/HTTP → UART → S3 OTA. S3에 OTA 수신 코드 필요. |

#### RTL 펌웨어 업그레이드

| 방법 | 필요 조건 | 설명 |
|------|-----------|------|
| **S3 패스스루 모드** | S3에서 RTL의 BOOT/RESET 제어 (GPIO 2개 추가 배선) | S3가 USB↔UART를 투명하게 중계(패스스루) + RTL을 부트모드로 전환. PC의 Arduino IDE가 S3의 USB를 통해 RTL에 플래시. S3에 패스스루 모드 코드 필요. |
| **UART OTA (RTL 자체)** | RTL 펌웨어에 UART OTA 수신 코드 내장 | S3가 PC에서 받은 `.bin`을 UART로 RTL에 청크 전달. RTL이 자체 OTA 파티션에 기록 → 재부팅. |
| **Wi-Fi OTA (RTL 직접)** | RTL HTTP OTA 엔드포인트 | PC → Wi-Fi → RTL HTTP `/ota` → Flash. USB 경유 없이 네트워크만으로 가능. |

---

### 2.3 옵션 C (USB 허브) 의 펌웨어 업그레이드

| 대상 | 방법 |
|------|------|
| **RTL** | PC에서 RTL COM 포트 선택 → Arduino IDE Upload (직접) |
| **S3** | PC에서 S3 COM 포트 선택 → Arduino IDE Upload (직접) |
| **OTA** | 옵션 A/B의 OTA 방법 모두 적용 가능 |

> 가장 단순하지만 USB 허브 IC의 보드 비용/면적 증가가 단점.

---

### 2.4 옵션 D (S3 하이브리드) 의 펌웨어 업그레이드

#### S3 펌웨어 업그레이드

| 방법 | 설명 |
|------|------|
| **USB 직접 플래시** | 옵션 B와 동일. Arduino IDE → USB-C → S3 직접 업로드. |

#### RTL 펌웨어 업그레이드

| 방법 | 필요 조건 | 설명 |
|------|-----------|------|
| **S3 플래시 에이전트** | S3에서 RTL BOOT/RESET GPIO 제어 (2개 배선) | S3에 "RTL 플래시 에이전트" 모드 구현. PC에서 S3 USB로 RTL `.bin` 전송 → S3가 RTL을 부트모드로 전환 → UART로 RTL에 기록 → 완료 후 정상 부팅. |
| **S3 USB-UART 패스스루** | 동일 GPIO 배선 | S3가 USB↔Serial1(UART)를 투명 중계. PC의 AmebaD 업로드 도구가 S3를 거쳐 RTL에 직접 통신. 더 단순하지만 S3를 패스스루 모드로 전환하는 UI/명령 필요. |
| **Wi-Fi OTA** | RTL HTTP OTA 엔드포인트 | PC → Wi-Fi → RTL `/ota`. USB 경유 불필요. 양산 후 현장 업데이트에 가장 적합. |

---

### 2.5 옵션 E (RTL 하이브리드) 의 펌웨어 업그레이드

#### RTL 펌웨어 업그레이드

| 방법 | 설명 |
|------|------|
| **USB 직접 플래시** | Arduino IDE에서 AmebaD 보드 선택 → USB-C 연결 → Upload. 가장 단순하고 표준적인 방법. 옵션 A와 동일. |
| **Wi-Fi OTA** | RTL이 HTTP `/ota` 엔드포인트 제공 → PC에서 `.bin` 업로드 → Flash OTA 파티션에 기록 → 재부팅. |

#### S3 펌웨어 업그레이드

| 방법 | 필요 조건 | 설명 |
|------|-----------|------|
| **RTL USB-UART 패스스루** | RTL에서 S3의 GPIO0(BOOT) + EN(RESET) 제어 (GPIO 2개 배선) | RTL이 USB↔Serial1(UART)를 투명 중계(패스스루) + S3를 부트모드로 전환. PC의 Arduino IDE(esptool)가 RTL을 거쳐 S3에 직접 플래시. RTL에 패스스루 모드 코드 필요. |
| **SPI OTA (RTL → S3)** ✅ v0.1.9 | S3 펌웨어에 OTA 수신 코드 내장 + OTA 파티션 | RTL이 PC에서 WS로 받은 `.bin`을 SPI로 S3에 전달 (DcmSpiHdr + CRC16). S3가 `Update.h`로 OTA 파티션에 기록 → 재부팅. UART 대비 ~15배 고속. |
| **Wi-Fi → RTL → SPI → S3** ✅ v0.1.9 | WS OTA + SPI OTA | PC → Wi-Fi → RTL WS `@ota,start,s3` → SPI → S3 OTA. 완전 무선, 고속. |

> **옵션 D vs E 펌웨어 업그레이드 비교:**
>
> | 항목 | D: S3 하이브리드 | E: RTL 하이브리드 |
> |------|:---:|:---:|
> | USB 직접 플래시 대상 | S3 | RTL |
> | 패스스루 플래시 대상 | RTL (S3가 중계) | S3 (RTL이 중계) |
> | 패스스루 구현 위치 | S3 펌웨어 | RTL 펌웨어 |
> | GPIO 제어 방향 | S3 → RTL BOOT/EN | RTL → S3 BOOT/EN |
> | Wi-Fi OTA | 동일 (양쪽 모두 가능) | 동일 (양쪽 모두 가능) |
> | OTA 누적 단계 | 동일 (단계 1→2→3) | 동일 (단계 1→2→3) |

---

## 3. 추천 설계 및 펌웨어 업그레이드 방안

### 3.1 추천 설계: 옵션 D (S3 하이브리드) 또는 옵션 E (RTL 하이브리드)

> D와 E는 구조적으로 대칭이며, **어떤 칩의 디버깅을 우선시하느냐**에 따라 선택합니다.
> 펌웨어 업그레이드 누적 단계(1→2→3)는 D/E 모두 동일하게 적용됩니다.

**D vs E 최종 비교:**

| 판단 기준 | D: S3 하이브리드 | E: RTL 하이브리드 |
|-----------|:---:|:---:|
| USB 직접 디버그 | S3 (모터/카메라/LED) | RTL (Wi-Fi/WS/네트워크) |
| 현재 코드 호환 | ○ 일부 수정 필요 | ★ 그대로 사용 가능 |
| USB-OTG 확장 | ★ 가능 | — 불가 |
| 자동 부트모드 (DTR/RTS) | ★ S3 지원 | — RTL 미지원 |
| 패스스루 구현 난이도 | S3에 ~100줄 | RTL에 ~100줄 |
| 단일 실패점 | S3 죽으면 USB 불가 | RTL 죽으면 USB 불가 |
| 개발 단계 추천 | 로봇 하드웨어 디버깅 집중 | 네트워크/통신 디버깅 집중 |
| 양산 후 차이 | OTA 사용 시 D/E 동일 | OTA 사용 시 D/E 동일 |

**추천:**

| 상황 | 추천 옵션 | 이유 |
|------|-----------|------|
| **신규 보드 설계** | **D (S3 하이브리드)** | S3가 메인 MCU(카메라/모터/LED)이므로 직접 디버그 우선. USB-OTG 확장성. DTR/RTS 자동 부트모드. |
| **현재 코드 빠른 적용** | **E (RTL 하이브리드)** | 기존 코드 수정 없이 즉시 사용. Wi-Fi/WS 네트워크 디버그 직접 확인. |
| **프로토타입 → 양산** | **E → D 전환** | 프로토타입은 E로 빠르게 검증 → 양산 보드 설계 시 D로 전환. OTA 단계는 동일하게 적용. |

**D 선택 시 필요 추가 배선 (GPIO 2개):**

```
ESP32-S3 GPIO_A ──→ RTL8720DN CHIP_EN (RESET)
ESP32-S3 GPIO_B ──→ RTL8720DN BOOT/LOG_TX (부트모드 제어)
```

**E 선택 시 필요 추가 배선 (GPIO 2개):**

```
RTL8720DN GPIO_X ──→ ESP32-S3 GPIO0 (BOOT)
RTL8720DN GPIO_Y ──→ ESP32-S3 EN    (RESET)
```

---

### 3.2 펌웨어 업그레이드 — 누적 단계별 구현 (D/E 공통)

> **옵션 D와 E 모두 동일한 누적 단계**를 적용합니다.
> 차이는 "USB 직접 플래시 대상"과 "패스스루 방향"뿐이며, OTA 단계는 완전히 동일합니다.
>
> 이전 단계 위에 쌓이는 **누적 구조**이며, 단계 3을 구현해도 단계 1/2의 기능은 그대로 유지됩니다.

```
┌─────────────────────────────────────────────────────────┐
│ 단계 2: Wi-Fi OTA (v0.1.9 구현 완료)                      │
│   RTL 직접 WS OTA + S3 SPI OTA (완전 무선, 고속)          │
├─────────────────────────────────────────────────────────┤
│ 단계 1: USB 패스스루                                      │
│   S3 직접 플래시 + RTL 패스스루 플래시 (유선 개발 기반)    │
└─────────────────────────────────────────────────────────┘
```

**누적 기능 매트릭스:**

| 업데이트 경로 | 단계 1 | +단계 2 (v0.1.9) |
|---------------|:---:|:---:|
| USB → S3 직접 플래시 | ✅ | ✅ |
| USB → S3 패스스루 → RTL 플래시 | ✅ | ✅ |
| Wi-Fi → RTL WS OTA | — | ✅ |
| Wi-Fi → RTL → SPI → S3 OTA | — | ✅ (고속) |

---

#### 단계 1: USB 패스스루 (개발 기반 — 필수)

> 모든 후속 단계의 기초. USB 케이블로 양쪽 펌웨어를 자유롭게 플래시.

```
[개발 PC]
  │
  ├─ S3 플래시: USB-C → S3 직접 (Arduino IDE, 표준 방식)
  │
  └─ RTL 플래시: USB-C → S3(패스스루 모드) → UART → RTL
                  S3가 USB↔UART를 투명 중계
                  RTL은 부트모드 (S3가 GPIO로 제어)
                  PC의 AmebaD 업로드 도구가 그대로 동작
```

**구현 내용:**

| 구현 항목 | 위치 | 난이도 | 설명 |
|-----------|------|--------|------|
| 패스스루 모드 진입 | S3 | 낮음 | `@passthru` 시리얼 명령 수신 시 USB↔UART 브릿지 모드로 전환 |
| RTL BOOT/RESET 제어 | S3 | 낮음 | GPIO로 RTL을 부트모드로 전환 후 패스스루 시작 |
| 패스스루 종료 | S3 | 낮음 | 타임아웃 또는 특수 시퀀스로 정상 모드 복귀 |

**이 단계의 특징:**
- 구현량 적음 (S3에 패스스루 모드 ~100줄)
- Arduino IDE의 기존 업로드 방식을 양쪽 모두 그대로 사용
- OTA 코드 없이도 양쪽 펌웨어 업데이트 가능
- 단, USB 케이블 연결 필수 (무선 불가)

---

#### 단계 2: Wi-Fi OTA 추가 (무선 업데이트 — v0.1.9 구현 완료)

> 단계 1 위에 추가. USB 없이 DeepCoConnector/테스트 페이지에서 무선으로 펌웨어 업데이트.
>
> **v0.1.9 변경**: UART OTA를 건너뛰고 **SPI OTA 직행**. 기존 SPI 카메라 링크(DcmSpiHdr + CRC16)를
> 그대로 활용하여 UART(~12KB/s) 대비 ~15배 빠른 전송 속도(~500KB/s) 달성.

```
[DeepCoConnector / PC 브라우저 / mini_dual_firmware_upload.html]
  │
  │  WebSocket ws://192.168.4.1/ws
  │
  ├─ RTL 펌웨어: @ota,start,rtl,<size> → WS binary chunks → @ota,end
  │              RTL이 Flash OTA 파티션에 직접 기록 → 재부팅
  │
  └─ S3 펌웨어:  @ota,start,s3,<size> → WS binary chunks → @ota,end
                 RTL이 WS binary 수신 → SPI(DcmSpiHdr type=OTA)로 S3 전달
                 S3가 Update.h로 OTA 파티션에 기록 → 재부팅
```

**구현 내용 (단계 1에 누적):**

| 구현 항목 | 위치 | 상태 | 설명 |
|-----------|------|------|------|
| WS OTA 핸들러 (RTL 자체) | RTL | ✅ DONE | `@ota,start,rtl` → WS binary → Flash 기록 → `sys_reset()` |
| SPI OTA 전송기 (RTL→S3) | RTL | ✅ DONE | `@ota,start,s3` → WS binary를 SPI(DcmSpiHdr type=OTA)로 중계 |
| SPI OTA 수신기 (S3) | S3 | ✅ DONE | `spiSlavePoll()`에서 OTA 블록 감지 → `Update.h`로 Flash 기록 |
| S3 OTA 파티션 테이블 | S3 | ✅ DONE | `partitions.csv`에 `ota_0` + `ota_1` 이미 구성됨 |
| OTA 테스트 UI | HTML | ✅ DONE | `mini_dual_firmware_upload.html` — 파일 선택/업로드/진행률/로그 |
| `dcm_spi_protocol.h` OTA 타입 | 공통 | ✅ DONE | `SPI_TYPE_OTA=2`, `SPI_TYPE_OTA_ACK=3`, `SPI_FLAG_OTA_ERR` |

> **OTA 파티션 비교:**
>
> **RTL8720DN** — AmebaD SDK 기본 플래시 레이아웃 (별도 설정 불필요):
>
> ```
> RTL8720DN Flash (2MB)
> ┌──────────────────┐ 0x000000
> │ Bootloader       │ ← OTA1/OTA2 중 유효한 쪽을 자동 부팅
> ├──────────────────┤ 0x004000
> │ OTA1 (FW)        │ ← 현재 실행 중인 펌웨어
> ├──────────────────┤ 0x104000
> │ OTA2 (FW)        │ ← 새 펌웨어 기록 영역 → 재부팅 시 전환
> ├──────────────────┤ 0x1E4000
> │ System / Data    │ ← Wi-Fi 캘리브레이션, 설정 등
> └──────────────────┘ 0x200000
> → SDK가 OTA 듀얼 파티션을 기본 포함. API 호출만으로 OTA 가능.
> ```
>
> **ESP32-S3** — 기본 파티션 (OTA 없음) vs OTA 파티션 (수정 필요):
>
> ```
> 기본 파티션 (OTA 불가)              OTA 파티션 (partitions.csv 수정 후)
> ┌──────────────────┐ 0x000000     ┌──────────────────┐ 0x000000
> │ bootloader       │              │ bootloader       │
> ├──────────────────┤ 0x008000     ├──────────────────┤ 0x008000
> │ partition table  │              │ partition table  │
> ├──────────────────┤ 0x009000     ├──────────────────┤ 0x009000
> │ nvs              │              │ nvs              │
> ├──────────────────┤ 0x00E000     ├──────────────────┤ 0x00E000
> │                  │              │ otadata          │ ← OTA 전환 정보
> ├──────────────────┤ 0x010000     ├──────────────────┤ 0x010000
> │ factory (app)    │ ← 단일 앱   │ ota_0 (app)      │ ← 현재 펌웨어
> │                  │    OTA 불가  ├──────────────────┤ 0x1F0000
> │                  │              │ ota_1 (app)      │ ← 새 펌웨어
> ├──────────────────┤              ├──────────────────┤ 0x3D0000
> │ spiffs           │              │ spiffs           │
> └──────────────────┘              └──────────────────┘
> → partitions.csv를 수정해야 OTA 가능.
> ```
>
> ```
> # ESP32-S3 partitions.csv (OTA 지원)
> # Name,    Type, SubType, Offset,   Size
> nvs,       data, nvs,     0x9000,   0x5000
> otadata,   data, ota,     0xe000,   0x2000
> ota_0,     app,  ota_0,   0x10000,  0x1E0000  # ~1.9MB
> ota_1,     app,  ota_1,   0x1F0000, 0x1E0000  # ~1.9MB
> spiffs,    data, spiffs,  0x3D0000, 0x30000
> ```

**SPI OTA 프로토콜 (v0.1.9 구현):**

> UART OTA(base64, 115200bps, ~12KB/s)를 건너뛰고 SPI OTA를 직접 구현.
> 기존 DcmSpiHdr 카메라 프로토콜에 `type=OTA(2)` + `type=OTA_ACK(3)` 추가.

```
RTL → S3 (SPI Master TX):
  DcmSpiHdr { type=SPI_TYPE_OTA, flags=START } → S3 Update.begin()
  DcmSpiHdr { type=SPI_TYPE_OTA, payload=FW chunk, crc16 } → S3 Update.write()
  DcmSpiHdr { type=SPI_TYPE_OTA, payload=FW chunk, crc16 } → S3 Update.write()
  ...
  DcmSpiHdr { type=SPI_TYPE_OTA, flags=END } → S3 Update.end() → ESP.restart()

S3 → RTL (SPI Slave TX, 파이프라인 응답):
  DcmSpiHdr { type=SPI_TYPE_OTA_ACK, total_len=received, flags=0|ERR }
```

**전송 속도 (SPI 4MHz, 2KB 블록):**

| 펌웨어 크기 | UART 115200 (미구현) | SPI 4MHz (구현) | 개선 |
|-------------|---------------------|-----------------|------|
| 200KB | ~25초 | ~0.5초 | 50배 |
| 500KB | ~60초 | ~1.5초 | 40배 |
| 1.87MB (S3 max) | ~2분 40초 | ~10초 | 16배 |

**이 단계의 특징:**
- USB 없이 완전 무선 업데이트 가능
- 기존 SPI 카메라 링크를 그대로 재사용 (새 통신 경로 없음)
- CRC16-CCITT 무결성 검증이 프로토콜에 내장
- OTA 실패 시 S3 자동 롤백 (ota_0/ota_1 듀얼 파티션)
- RTL OTA 실패 시 Flash 서명 복원 (새 이미지 무효화 + 기존 복원)

---

### 3.3 구현 순서 요약

```
단계 1 (즉시 — 개발 시작 전 필수)
  └─ USB 패스스루
     ✅ S3 직접 플래시 (USB)
     ✅ RTL 패스스루 플래시 (USB → S3 → UART → RTL)
     → 구현: S3에 ~100줄 추가

단계 2 (v0.1.9 — 구현 완료)
  └─ + Wi-Fi OTA (WS + SPI 경유)
     ✅ RTL WS OTA (@ota,start,rtl → Flash)
     ✅ S3 SPI OTA (@ota,start,s3 → RTL → SPI → S3)
     ✅ OTA 테스트 UI (mini_dual_firmware_upload.html)
     ✅ dcm_spi_protocol.h OTA 타입 (SPI_TYPE_OTA, SPI_TYPE_OTA_ACK)
     → 구현: RTL ~250줄 + S3 ~150줄 + 프로토콜 헤더 + HTML
```

---

### 3.4 보드 설계 요구사항 요약

**공통 (D/E 모두 동일):**

| 항목 | 내용 |
|------|------|
| 전원 | USB 5V → 3.3V 레귤레이터 → RTL + S3 공급 |
| UART | S3 TX/RX ↔ RTL Serial1 TX/RX (제어 명령, 양방향) |
| SPI | S3 SPI Slave ↔ RTL SPI Master (카메라, 단방향) |
| 공통 GND | 필수 |

**옵션별 차이:**

| 항목 | D: S3 하이브리드 | E: RTL 하이브리드 |
|------|------|------|
| USB-C 연결 | ESP32-S3 USB 핀 | RTL8720DN USB 핀 |
| GPIO 2개 방향 | S3 → RTL (CHIP_EN + BOOT) | RTL → S3 (EN + GPIO0) |
| 패스스루 코드 위치 | S3 펌웨어 | RTL 펌웨어 |

---

## 4. 옵션 E 개발 — DevKit 테스트 환경

> **3.1절에서 프로토타입 단계에는 옵션 E (RTL 하이브리드)를 추천**했습니다.
> 옵션 E는 현재 코드와 100% 호환되며, USB-C가 RTL에 연결된 구조입니다.
>
> 커스텀 보드(USB-C 1개)를 만들기 전에, 먼저 **두 개의 devkit**으로
> 옵션 E의 모든 기능을 검증합니다:
>
> - **BW16 Kit** — RTL8720DN devkit (USB-C 내장)
> - **ESP32-S3-CAM DevKit** — S3 devkit (USB-C 내장)
>
> devkit은 각각 자체 USB-C가 있으므로, 개발 중에는 **각 칩을 직접 플래시**하고,
> 검증 단계에서는 **패스스루/OTA를 커스텀 보드와 동일한 조건**으로 테스트할 수 있습니다.
>
> ```
> 개발 흐름:
>   옵션 E 선택 (3.1절)
>     → devkit으로 검증 (이 섹션)
>       → 커스텀 보드 설계 (3.4절 요구사항 기반)
> ```

### 4.1 옵션 E devkit 배선도 (config.h 기준)

> 아래 배선은 **옵션 E (RTL 하이브리드)** 구조를 devkit 2개로 재현한 것입니다.
> 핀 번호는 `rtl8720dn/config.h`와 `esp32s3/config.h`에 정의된 실제 값입니다.

```
┌──────────────────────────┐              ┌──────────────────────────┐
│     BW16 Kit (RTL)       │              │   ESP32-S3-CAM DevKit    │
│     ──────────────       │              │   ──────────────────     │
│                          │              │                          │
│  [USB-C] ← RTL 직접플래시 │              │  [USB-C] ← S3 직접플래시  │
│                          │              │                          │
│  ── UART (제어 명령) ──────┤              ├──────────────────────── │
│  Serial1 TX = D4 (PB1) ──┼──────────→──┤ UART0 RX = GPIO44       │
│  Serial1 RX = D5 (PB2) ──┼──←──────────┤ UART0 TX = GPIO43       │
│                          │              │                          │
│  ── SPI (카메라 JPEG) ────┤              ├──────────────────────── │
│  SS   = D3  (PA30) ──────┼──────────→──┤ CS   = GPIO46            │
│  SCLK = D10 (PA14) ──────┼──────────→──┤ SCLK = GPIO21            │
│  MOSI = D12 (PA12) ──────┼──────────→──┤ MOSI = GPIO14            │
│  MISO = D11 (PA13) ──────┼──←──────────┤ MISO = GPIO3             │
│                          │              │                          │
│  ── GPIO (패스스루 제어) ──┤              ├──────────────────────── │
│  D6 (PA26) ──────────────┼──────────→──┤ EN   (리셋)              │
│  D7 (PA25) ──────────────┼──────────→──┤ GPIO0 (부트모드)         │
│                          │              │                          │
│  GND ────────────────────┼──────────────┤ GND                     │
└──────────────────────────┘              └──────────────────────────┘
```

### 4.2 배선 핀 매핑 요약표

| 기능 | BW16 (RTL) 핀 | 방향 | ESP32-S3-CAM 핀 | 비고 |
|------|:---:|:---:|:---:|------|
| **UART TX** | D4 (PB1) | → | GPIO44 (RX) | 제어 명령 (115200 baud) |
| **UART RX** | D5 (PB2) | ← | GPIO43 (TX) | 상태/로그 수신 |
| **SPI SS** | D3 (PA30) | → | GPIO46 | Slave Select |
| **SPI SCLK** | D10 (PA14) | → | GPIO21 | 클록 (10MHz) (v0.2.1: GPIO45→21) |
| **SPI MOSI** | D12 (PA12) | → | GPIO14 | RTL→S3 데이터 (v0.2.1: GPIO20→14) |
| **SPI MISO** | D11 (PA13) | ← | GPIO3 | S3→RTL 데이터 (v0.2.1: GPIO19→3) |
| **S3 EN** | D6 (PA26) | → | EN | 리셋 제어 (패스스루용) |
| **S3 BOOT** | D7 (PA25) | → | GPIO0 | 부트모드 제어 (패스스루용) |
| **GND** | GND | — | GND | 공통 접지 (필수!) |

> **전원 참고:** devkit에서는 각 보드가 자체 USB로 전원을 공급받으므로
> 별도 전원 연결 불필요. 단, **GND는 반드시 연결**해야 UART/SPI 통신이 정상 동작.

### 4.3 옵션 E 검증 테스트 시나리오

| # | 테스트 항목 | USB 연결 | 방법 |
|---|-----------|---------|------|
| 1 | RTL 직접 플래시 | RTL USB → PC | Arduino IDE → BW16 보드 → Upload |
| 2 | S3 직접 플래시 | S3 USB → PC | Arduino IDE → ESP32-S3 보드 → Upload |
| 3 | 양쪽 동시 디버그 | 양쪽 USB 모두 → PC | 시리얼 모니터 2개로 RTL/S3 로그 동시 확인 |
| 4 | 정상 운영 테스트 | 양쪽 USB 모두 → PC | Wi-Fi AP 접속 → WS 제어/카메라 스트리밍 검증 |
| 5 | **@passthru 테스트** | **RTL USB만** → PC (**S3 USB 분리!**) | `@passthru` → esptool이 RTL 경유 S3 플래시 |
| 6 | Wi-Fi OTA 테스트 (향후) | USB 없이 전원만 | Wi-Fi AP 접속 → HTTP `/ota`, `/ota_s3` |

### 4.4 옵션 E devkit 개발 → 커스텀 보드 전환 단계

```
[1단계: 기본 기능 개발] — USB 두 개 활용 (devkit 장점!)
  ├─ RTL 펌웨어 수정 → RTL USB로 직접 업로드
  ├─ S3 펌웨어 수정  → S3 USB로 직접 업로드
  └─ 양쪽 시리얼 모니터로 실시간 디버그

[2단계: 옵션 E 패스스루 검증] — RTL USB만 사용 (커스텀 보드 시뮬레이션)
  ├─ ⚠️  S3 USB 케이블 분리 (native USB와 UART 부트 충돌 방지)
  ├─ @passthru 명령으로 S3 플래시 성공 확인
  └─ 커스텀 보드(USB-C 1개 = RTL에 연결)와 동일 조건 재현

[3단계: OTA 검증] — USB 없이 Wi-Fi만 (누적 단계 2, 3.2절)
  ├─ 양쪽 USB 분리 (전원만 공급, 또는 배터리)
  ├─ Wi-Fi AP 접속 → HTTP OTA 테스트
  └─ 양산 환경과 동일 조건 재현

[4단계: 커스텀 보드 설계] — devkit에서 옵션 E 검증 완료 후
  ├─ 4.2절 핀 매핑을 커스텀 PCB 회로도에 반영
  ├─ USB-C 1개만 탑재 (RTL에 연결 = 옵션 E)
  ├─ 3.4절 보드 설계 요구사항 적용
  └─ devkit에서 검증된 모든 기능이 그대로 동작
```

### 4.5 devkit 주의사항

| 주의 | 설명 |
|------|------|
| **@passthru 시 S3 USB 분리** | S3의 native USB와 UART 부트가 동시 활성화되면 충돌. 패스스루 테스트 시 S3 USB 케이블을 반드시 뽑을 것. |
| **GND 공유 필수** | 두 devkit 간 GND를 연결하지 않으면 UART/SPI 신호 레벨이 불안정하여 통신 실패. |
| **SPI 배선 길이** | devkit 간 점퍼선이 길면 30MHz SPI가 불안정할 수 있음. 10cm 이내 권장. 불안정하면 `CFG_SPI_HZ`를 10MHz로 낮출 것. |
| **S3 PSRAM 예약 핀 주의** | GPIO35/36/37은 PSRAM과 충돌 가능성이 있어 SPI 사용자 핀으로 사용하지 않음. 현재 SPI는 GPIO21/14/3/46 (SCLK/MOSI/MISO/CS). v0.2.1에서 GPIO45(VDD_SPI strapping)/19(USB D+)/20(USB D-) 회피. CS(GPIO46)는 boot strapping이지만 부팅 로그만 영향(경미). |
| **S3-CAM devkit GPIO0** | 일부 devkit에 GPIO0 풀업 저항/버튼이 있음. RTL이 LOW로 강제 구동하므로 보통 문제없지만, 동작 안 하면 devkit 회로도 확인. |
| **Serial1 핀 확인** | BW16의 Serial1은 variant에 의해 D4(TX)/D5(RX)로 고정. 다른 RTL devkit이면 핀 번호 확인 필요. |
