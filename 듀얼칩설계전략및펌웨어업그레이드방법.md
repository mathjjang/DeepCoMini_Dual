# 듀얼칩 설계 전략 및 펌웨어 업그레이드 방법

> DeepCo_Dual (ESP32-S3 + RTL8720DN) 보드의 USB-C 포트 연결 전략과
> 각 전략별 펌웨어 업그레이드 방법을 정리한 문서입니다.

---

## 1. 설계 전략 비교

### 1.1 전제 조건

- 보드에 **USB-C 포트 1개**만 존재
- 용도: **5V 전원 공급** + **시리얼 통신** (펌웨어 플래시 / 디버그 로그)
- 칩 간 연결: UART (제어 명령) + SPI (카메라 JPEG)
- 목표: 하나의 USB-C로 개발/디버그/OTA를 최대한 커버

---

### 1.2 옵션 A: USB-C → RTL8720DN

```
[USB-C] ── RTL8720DN ──UART──> ESP32-S3
               │                   │
          Wi-Fi AP              카메라/모터
          WS 서버               SPI Slave
          USB Serial
```

| 장점 | 단점 |
|------|------|
| 네트워크(Wi-Fi/WS) 로그를 USB에서 직접 확인 | S3 펌웨어 플래시에 RTL 경유 필요 |
| RTL 펌웨어 USB 직접 업로드 가능 | S3 저수준 디버그(crash dump) 직접 확인 불가 |
| S3 로그 중계(`@log,`) 이미 구현됨 | S3 부트모드 진입에 추가 GPIO 2개 필요 |
| `@set,channel` 등 RTL 설정 명령 바로 입력 가능 | RTL이 죽으면 USB 통신 자체 불가 (단일 실패점) |
| **현재 코드와 100% 호환** | — |

---

### 1.3 옵션 B: USB-C → ESP32-S3

```
           RTL8720DN ──UART──> ESP32-S3 ── [USB-C]
              │                    │
         Wi-Fi AP              카메라/모터
         WS 서버               USB Serial
                               SPI Slave
```

| 장점 | 단점 |
|------|------|
| S3 펌웨어를 Arduino IDE / esptool로 직접 업로드 | RTL 펌웨어 플래시에 S3 경유 필요 |
| S3 crash dump, stack trace 직접 확인 | RTL 디버그 로그를 보려면 중계 코드 추가 필요 |
| ESP32-S3 USB-OTG 활용 가능 (향후 확장) | 현재 코드 구조 리팩토링 필요 |
| 자동 부트모드 진입 (DTR/RTS) 지원 | RTL `@set,channel` 등 명령이 S3 경유 |
| 모터/카메라/LED 상태 USB에서 바로 확인 | Wi-Fi 문제 디버깅 시 RTL 로그 간접 확인 |

---

### 1.4 옵션 C: USB-C → USB 허브 → 양쪽 모두

```
[USB-C] ── USB Hub IC ┬── RTL8720DN
                      └── ESP32-S3
```

| 장점 | 단점 |
|------|------|
| 양쪽 모두 직접 플래시/디버그 가능 | USB 허브 IC 추가 (보드 복잡도/비용 증가) |
| PC에서 두 개의 COM 포트로 인식 | 보드 면적 증가, 소형화 불리 |
| 가장 유연한 개발 환경 | BOM 비용 상승 |

---

### 1.5 옵션 D: USB-C → S3 + S3가 RTL 플래시 대행 (하이브리드)

```
[USB-C] ── ESP32-S3 ──UART──> RTL8720DN
               │
          GPIO로 RTL의 BOOT/RESET 제어
```

| 장점 | 단점 |
|------|------|
| S3 플래시: USB 직접 (표준 ESP32 방식) | S3에 RTL 플래시 에이전트 코드 구현 필요 |
| RTL 플래시: S3 경유 UART 부트로더 | 개발 초기에는 RTL 별도 플래시 필요 |
| 하나의 USB-C로 양쪽 모두 플래시 가능 | RTL 디버그 로그는 S3 경유 간접 확인 |
| 보드 추가 비용 최소 (GPIO 2개만 추가) | — |
| ESP32-S3 USB-OTG 활용 가능 | — |

---

### 1.6 옵션 E: USB-C → RTL + RTL이 S3 플래시 대행 (RTL 하이브리드)

```
[USB-C] ── RTL8720DN ──UART──> ESP32-S3
               │                   │
          Wi-Fi AP              카메라/모터
          WS 서버               SPI Slave
          USB Serial
          GPIO로 S3의 BOOT/EN 제어
```

> 옵션 A의 확장판. USB-C는 RTL에 연결하되, RTL이 GPIO 2개로 S3의 부트모드/리셋을
> 제어하여 패스스루 플래시도 가능하게 한 구조.

| 장점 | 단점 |
|------|------|
| RTL 펌웨어 USB 직접 업로드 (표준 AmebaD 방식) | S3 디버그(crash dump, stack trace) 간접 확인 |
| S3 플래시: RTL 패스스루 → UART → S3 (GPIO로 부트모드 진입) | S3 USB-OTG 활용 불가 |
| 하나의 USB-C로 양쪽 모두 플래시 가능 | RTL이 죽으면 USB 통신 자체 불가 (단일 실패점) |
| **현재 코드 구조 100% 호환** (USB가 RTL 측) | RTL→S3 패스스루 시 esptool 프로토콜 중계 구현 필요 |
| Wi-Fi/WS 네트워크 로그를 USB에서 직접 확인 | — |
| `@set,channel` 등 RTL 설정 명령 바로 입력 가능 | — |
| 보드 비용 최소 (GPIO 2개만 추가) | — |
| Wi-Fi OTA로 양쪽 모두 커버 가능 | — |

**필요 추가 배선 (GPIO 2개):**

```
RTL8720DN GPIO_X ──→ ESP32-S3 GPIO0 (BOOT)
RTL8720DN GPIO_Y ──→ ESP32-S3 EN   (RESET)
```

**옵션 D (S3 하이브리드) vs 옵션 E (RTL 하이브리드) 핵심 차이:**

| 비교 항목 | D: S3 하이브리드 | E: RTL 하이브리드 |
|-----------|:---:|:---:|
| USB 직접 연결 칩 | S3 | RTL |
| 직접 디버그 대상 | S3 (모터/카메라/LED) | RTL (Wi-Fi/WS/네트워크) |
| USB-OTG 확장 | ★ 가능 | — 불가 |
| 현재 코드 호환 | ○ 일부 수정 | ★ 그대로 |
| 패스스루로 플래시하는 칩 | RTL (S3가 중계) | S3 (RTL이 중계) |
| GPIO 제어 방향 | S3 → RTL BOOT/EN | RTL → S3 BOOT/EN |

---

### 1.7 종합 비교표

| 기준 | A: USB→RTL | B: USB→S3 | C: 허브 | D: S3 하이브리드 | E: RTL 하이브리드 |
|------|:---:|:---:|:---:|:---:|:---:|
| S3 플래시 용이성 | ▲ 어려움 | ★ 쉬움 | ★ 쉬움 | ★ 쉬움 | ○ 중간 (패스스루) |
| RTL 플래시 용이성 | ★ 쉬움 | ▲ 어려움 | ★ 쉬움 | ○ 중간 (패스스루) | ★ 쉬움 |
| S3 디버그 | ○ 간접 | ★ 직접 | ★ 직접 | ★ 직접 | ○ 간접 |
| RTL 디버그 | ★ 직접 | ○ 간접 | ★ 직접 | ○ 간접 | ★ 직접 |
| 현재 코드 호환 | ★ 그대로 | ▲ 리팩토링 | ○ 양쪽 수정 | ○ 일부 수정 | ★ 그대로 |
| 보드 비용 | ★ 낮음 | ★ 낮음 | ▲ 높음 | ★ 낮음 | ★ 낮음 |
| OTA 친화도 | ○ RTL 유리 | ○ S3 유리 | ★ 양쪽 | ★ 양쪽 | ★ 양쪽 |
| 향후 확장성 | ○ 보통 | ★ USB-OTG | ★ 높음 | ★ USB-OTG | ○ 보통 |
| 추가 하드웨어 | 없음 | 없음 | 허브 IC | GPIO 2개 | GPIO 2개 |
| 단일 실패점 | RTL | S3 | 없음 | S3 | RTL |

> ★ 우수 / ○ 보통 / ▲ 부족

---

## 2. 옵션별 펌웨어 업그레이드 방법

### 2.1 옵션 A (USB→RTL) 의 펌웨어 업그레이드

#### RTL 펌웨어 업그레이드

| 방법 | 설명 |
|------|------|
| **USB 직접 플래시** | Arduino IDE에서 AmebaD 보드 선택 → USB-C 연결 → Upload. 가장 단순하고 표준적인 방법. |
| **Wi-Fi OTA** | RTL이 HTTP `/ota` 엔드포인트를 제공 → PC에서 `.bin` 업로드 → Flash OTA 파티션에 기록 → 재부팅. AmebaD SDK OTA 지원 활용. |

#### S3 펌웨어 업그레이드

| 방법 | 필요 조건 | 설명 |
|------|-----------|------|
| **UART 부트로더 경유** | RTL에서 S3의 GPIO0 + EN 제어 (GPIO 2개 추가 배선) | RTL이 S3를 부트모드로 전환 → UART로 esptool 프로토콜 실행 → 플래시 완료 후 정상 부팅. PC에서 RTL을 "패스스루" 모드로 전환하여 esptool이 RTL의 USB-UART를 통해 S3에 직접 통신. |
| **UART OTA (S3 자체)** | S3 펌웨어에 OTA 수신 코드 내장 + OTA 파티션 | RTL이 PC에서 받은 `.bin`을 UART로 S3에 청크 전달 (`@ota,start` / `@ota,data` / `@ota,end`). S3가 `Update.h`로 OTA 파티션에 기록 → 검증 → 재부팅. 추가 배선 불필요하지만 S3 펌웨어에 OTA 코드가 있어야 함. |
| **Wi-Fi → RTL → UART → S3** | 위 UART OTA + RTL HTTP OTA 엔드포인트 | PC → Wi-Fi → RTL HTTP → UART → S3 OTA. 완전 무선. |

---

### 2.2 옵션 B (USB→S3) 의 펌웨어 업그레이드

#### S3 펌웨어 업그레이드

| 방법 | 설명 |
|------|------|
| **USB 직접 플래시** | Arduino IDE에서 ESP32-S3 보드 선택 → USB-C 연결 → Upload. 자동 부트모드 진입(DTR/RTS). 가장 단순. |
| **Wi-Fi OTA (RTL 경유)** | PC → Wi-Fi → RTL WS/HTTP → UART → S3 OTA. S3에 OTA 수신 코드 필요. |

#### RTL 펌웨어 업그레이드

| 방법 | 필요 조건 | 설명 |
|------|-----------|------|
| **S3 패스스루 모드** | S3에서 RTL의 BOOT/RESET 제어 (GPIO 2개 추가 배선) | S3가 USB↔UART를 투명하게 중계(패스스루) + RTL을 부트모드로 전환. PC의 Arduino IDE가 S3의 USB를 통해 RTL에 플래시. S3에 패스스루 모드 코드 필요. |
| **UART OTA (RTL 자체)** | RTL 펌웨어에 UART OTA 수신 코드 내장 | S3가 PC에서 받은 `.bin`을 UART로 RTL에 청크 전달. RTL이 자체 OTA 파티션에 기록 → 재부팅. |
| **Wi-Fi OTA (RTL 직접)** | RTL HTTP OTA 엔드포인트 | PC → Wi-Fi → RTL HTTP `/ota` → Flash. USB 경유 없이 네트워크만으로 가능. |

---

### 2.3 옵션 C (USB 허브) 의 펌웨어 업그레이드

| 대상 | 방법 |
|------|------|
| **RTL** | PC에서 RTL COM 포트 선택 → Arduino IDE Upload (직접) |
| **S3** | PC에서 S3 COM 포트 선택 → Arduino IDE Upload (직접) |
| **OTA** | 옵션 A/B의 OTA 방법 모두 적용 가능 |

> 가장 단순하지만 USB 허브 IC의 보드 비용/면적 증가가 단점.

---

### 2.4 옵션 D (S3 하이브리드) 의 펌웨어 업그레이드

#### S3 펌웨어 업그레이드

| 방법 | 설명 |
|------|------|
| **USB 직접 플래시** | 옵션 B와 동일. Arduino IDE → USB-C → S3 직접 업로드. |

#### RTL 펌웨어 업그레이드

| 방법 | 필요 조건 | 설명 |
|------|-----------|------|
| **S3 플래시 에이전트** | S3에서 RTL BOOT/RESET GPIO 제어 (2개 배선) | S3에 "RTL 플래시 에이전트" 모드 구현. PC에서 S3 USB로 RTL `.bin` 전송 → S3가 RTL을 부트모드로 전환 → UART로 RTL에 기록 → 완료 후 정상 부팅. |
| **S3 USB-UART 패스스루** | 동일 GPIO 배선 | S3가 USB↔Serial1(UART)를 투명 중계. PC의 AmebaD 업로드 도구가 S3를 거쳐 RTL에 직접 통신. 더 단순하지만 S3를 패스스루 모드로 전환하는 UI/명령 필요. |
| **Wi-Fi OTA** | RTL HTTP OTA 엔드포인트 | PC → Wi-Fi → RTL `/ota`. USB 경유 불필요. 양산 후 현장 업데이트에 가장 적합. |

---

### 2.5 옵션 E (RTL 하이브리드) 의 펌웨어 업그레이드

#### RTL 펌웨어 업그레이드

| 방법 | 설명 |
|------|------|
| **USB 직접 플래시** | Arduino IDE에서 AmebaD 보드 선택 → USB-C 연결 → Upload. 가장 단순하고 표준적인 방법. 옵션 A와 동일. |
| **Wi-Fi OTA** | RTL이 HTTP `/ota` 엔드포인트 제공 → PC에서 `.bin` 업로드 → Flash OTA 파티션에 기록 → 재부팅. |

#### S3 펌웨어 업그레이드

| 방법 | 필요 조건 | 설명 |
|------|-----------|------|
| **RTL USB-UART 패스스루** | RTL에서 S3의 GPIO0(BOOT) + EN(RESET) 제어 (GPIO 2개 배선) | RTL이 USB↔Serial1(UART)를 투명 중계(패스스루) + S3를 부트모드로 전환. PC의 Arduino IDE(esptool)가 RTL을 거쳐 S3에 직접 플래시. RTL에 패스스루 모드 코드 필요. |
| **UART OTA (RTL → S3)** | S3 펌웨어에 OTA 수신 코드 내장 + OTA 파티션 | RTL이 PC에서 받은 `.bin`을 UART로 S3에 청크 전달 (`@ota` 프로토콜). S3가 `Update.h`로 OTA 파티션에 기록 → 재부팅. 추가 배선 불필요. |
| **Wi-Fi → RTL → UART → S3** | 위 UART OTA + RTL HTTP 엔드포인트 | PC → Wi-Fi → RTL HTTP `/ota_s3` → UART → S3 OTA. 완전 무선. |
| **Wi-Fi → RTL → SPI → S3** | 위 + SPI OTA 타입 추가 | PC → Wi-Fi → RTL HTTP `/ota_s3` → SPI → S3 OTA. 고속 무선. (단계 3) |

> **옵션 D vs E 펌웨어 업그레이드 비교:**
>
> | 항목 | D: S3 하이브리드 | E: RTL 하이브리드 |
> |------|:---:|:---:|
> | USB 직접 플래시 대상 | S3 | RTL |
> | 패스스루 플래시 대상 | RTL (S3가 중계) | S3 (RTL이 중계) |
> | 패스스루 구현 위치 | S3 펌웨어 | RTL 펌웨어 |
> | GPIO 제어 방향 | S3 → RTL BOOT/EN | RTL → S3 BOOT/EN |
> | Wi-Fi OTA | 동일 (양쪽 모두 가능) | 동일 (양쪽 모두 가능) |
> | OTA 누적 단계 | 동일 (단계 1→2→3) | 동일 (단계 1→2→3) |

---

## 3. 추천 설계 및 펌웨어 업그레이드 방안

### 3.1 추천 설계: 옵션 D (S3 하이브리드) 또는 옵션 E (RTL 하이브리드)

> D와 E는 구조적으로 대칭이며, **어떤 칩의 디버깅을 우선시하느냐**에 따라 선택합니다.
> 펌웨어 업그레이드 누적 단계(1→2→3)는 D/E 모두 동일하게 적용됩니다.

**D vs E 최종 비교:**

| 판단 기준 | D: S3 하이브리드 | E: RTL 하이브리드 |
|-----------|:---:|:---:|
| USB 직접 디버그 | S3 (모터/카메라/LED) | RTL (Wi-Fi/WS/네트워크) |
| 현재 코드 호환 | ○ 일부 수정 필요 | ★ 그대로 사용 가능 |
| USB-OTG 확장 | ★ 가능 | — 불가 |
| 자동 부트모드 (DTR/RTS) | ★ S3 지원 | — RTL 미지원 |
| 패스스루 구현 난이도 | S3에 ~100줄 | RTL에 ~100줄 |
| 단일 실패점 | S3 죽으면 USB 불가 | RTL 죽으면 USB 불가 |
| 개발 단계 추천 | 로봇 하드웨어 디버깅 집중 | 네트워크/통신 디버깅 집중 |
| 양산 후 차이 | OTA 사용 시 D/E 동일 | OTA 사용 시 D/E 동일 |

**추천:**

| 상황 | 추천 옵션 | 이유 |
|------|-----------|------|
| **신규 보드 설계** | **D (S3 하이브리드)** | S3가 메인 MCU(카메라/모터/LED)이므로 직접 디버그 우선. USB-OTG 확장성. DTR/RTS 자동 부트모드. |
| **현재 코드 빠른 적용** | **E (RTL 하이브리드)** | 기존 코드 수정 없이 즉시 사용. Wi-Fi/WS 네트워크 디버그 직접 확인. |
| **프로토타입 → 양산** | **E → D 전환** | 프로토타입은 E로 빠르게 검증 → 양산 보드 설계 시 D로 전환. OTA 단계는 동일하게 적용. |

**D 선택 시 필요 추가 배선 (GPIO 2개):**

```
ESP32-S3 GPIO_A ──→ RTL8720DN CHIP_EN (RESET)
ESP32-S3 GPIO_B ──→ RTL8720DN BOOT/LOG_TX (부트모드 제어)
```

**E 선택 시 필요 추가 배선 (GPIO 2개):**

```
RTL8720DN GPIO_X ──→ ESP32-S3 GPIO0 (BOOT)
RTL8720DN GPIO_Y ──→ ESP32-S3 EN    (RESET)
```

---

### 3.2 펌웨어 업그레이드 — 누적 단계별 구현 (D/E 공통)

> **옵션 D와 E 모두 동일한 누적 단계**를 적용합니다.
> 차이는 "USB 직접 플래시 대상"과 "패스스루 방향"뿐이며, OTA 단계는 완전히 동일합니다.
>
> 이전 단계 위에 쌓이는 **누적 구조**이며, 단계 3을 구현해도 단계 1/2의 기능은 그대로 유지됩니다.

```
┌─────────────────────────────────────────────────────────┐
│ 단계 3: SPI 고속 OTA                                     │
│   Wi-Fi → RTL → SPI → S3 (수백 배 빠른 S3 무선 업데이트) │
├─────────────────────────────────────────────────────────┤
│ 단계 2: Wi-Fi OTA                                        │
│   RTL 직접 OTA + S3 UART OTA (완전 무선 업데이트)         │
├─────────────────────────────────────────────────────────┤
│ 단계 1: USB 패스스루                                      │
│   S3 직접 플래시 + RTL 패스스루 플래시 (유선 개발 기반)    │
└─────────────────────────────────────────────────────────┘
```

**누적 기능 매트릭스:**

| 업데이트 경로 | 단계 1 | +단계 2 | +단계 3 |
|---------------|:---:|:---:|:---:|
| USB → S3 직접 플래시 | ✅ | ✅ | ✅ |
| USB → S3 패스스루 → RTL 플래시 | ✅ | ✅ | ✅ |
| Wi-Fi → RTL HTTP OTA | — | ✅ | ✅ |
| Wi-Fi → RTL → UART → S3 OTA | — | ✅ (느림) | ✅ (느림) |
| Wi-Fi → RTL → SPI → S3 OTA | — | — | ✅ (빠름) |

---

#### 단계 1: USB 패스스루 (개발 기반 — 필수)

> 모든 후속 단계의 기초. USB 케이블로 양쪽 펌웨어를 자유롭게 플래시.

```
[개발 PC]
  │
  ├─ S3 플래시: USB-C → S3 직접 (Arduino IDE, 표준 방식)
  │
  └─ RTL 플래시: USB-C → S3(패스스루 모드) → UART → RTL
                  S3가 USB↔UART를 투명 중계
                  RTL은 부트모드 (S3가 GPIO로 제어)
                  PC의 AmebaD 업로드 도구가 그대로 동작
```

**구현 내용:**

| 구현 항목 | 위치 | 난이도 | 설명 |
|-----------|------|--------|------|
| 패스스루 모드 진입 | S3 | 낮음 | `@passthru` 시리얼 명령 수신 시 USB↔UART 브릿지 모드로 전환 |
| RTL BOOT/RESET 제어 | S3 | 낮음 | GPIO로 RTL을 부트모드로 전환 후 패스스루 시작 |
| 패스스루 종료 | S3 | 낮음 | 타임아웃 또는 특수 시퀀스로 정상 모드 복귀 |

**이 단계의 특징:**
- 구현량 적음 (S3에 패스스루 모드 ~100줄)
- Arduino IDE의 기존 업로드 방식을 양쪽 모두 그대로 사용
- OTA 코드 없이도 양쪽 펌웨어 업데이트 가능
- 단, USB 케이블 연결 필수 (무선 불가)

---

#### 단계 2: Wi-Fi OTA 추가 (무선 업데이트 — 양산 필수)

> 단계 1 위에 추가. USB 없이 DeepCoConnector에서 무선으로 펌웨어 업데이트.

```
[DeepCoConnector / PC 브라우저]
  │
  ├─ RTL 펌웨어: PC → Wi-Fi → http://192.168.4.1/ota (RTL 직접)
  │              RTL이 HTTP로 .bin 수신 → Flash OTA 파티션 → 재부팅
  │
  └─ S3 펌웨어:  PC → Wi-Fi → http://192.168.4.1/ota_s3 (RTL 경유)
                 RTL이 HTTP로 .bin 수신 → UART로 S3에 청크 전달
                 S3가 Update.h로 OTA 파티션에 기록 → 재부팅
```

**구현 내용 (단계 1에 누적):**

| 구현 항목 | 위치 | 난이도 | 설명 |
|-----------|------|--------|------|
| HTTP OTA 서버 (`/ota`) | RTL | 중간 | HTTP POST로 RTL .bin 수신 → AmebaD OTA API로 Flash 기록 (OTA 파티션은 SDK 기본 내장) |
| HTTP S3 OTA 프록시 (`/ota_s3`) | RTL | 중간 | HTTP POST로 S3 .bin 수신 → UART `@ota` 프로토콜로 S3에 전달 |
| UART OTA 수신기 | S3 | 중간 | `@ota,start,size` / `@ota,data,<base64>` / `@ota,end` 처리. ESP32 `Update.h` 사용 |
| S3 OTA 파티션 테이블 | S3 | 낮음 | `partitions.csv`에 `ota_0` + `ota_1` 파티션 추가 (S3만 필요, RTL은 SDK에 기본 포함) |
| OTA UI (선택) | DeepCoConnector | 낮음 | 파일 선택 → HTTP POST 전송 → 진행률 표시 |

> **OTA 파티션 비교:**
>
> **RTL8720DN** — AmebaD SDK 기본 플래시 레이아웃 (별도 설정 불필요):
>
> ```
> RTL8720DN Flash (2MB)
> ┌──────────────────┐ 0x000000
> │ Bootloader       │ ← OTA1/OTA2 중 유효한 쪽을 자동 부팅
> ├──────────────────┤ 0x004000
> │ OTA1 (FW)        │ ← 현재 실행 중인 펌웨어
> ├──────────────────┤ 0x104000
> │ OTA2 (FW)        │ ← 새 펌웨어 기록 영역 → 재부팅 시 전환
> ├──────────────────┤ 0x1E4000
> │ System / Data    │ ← Wi-Fi 캘리브레이션, 설정 등
> └──────────────────┘ 0x200000
> → SDK가 OTA 듀얼 파티션을 기본 포함. API 호출만으로 OTA 가능.
> ```
>
> **ESP32-S3** — 기본 파티션 (OTA 없음) vs OTA 파티션 (수정 필요):
>
> ```
> 기본 파티션 (OTA 불가)              OTA 파티션 (partitions.csv 수정 후)
> ┌──────────────────┐ 0x000000     ┌──────────────────┐ 0x000000
> │ bootloader       │              │ bootloader       │
> ├──────────────────┤ 0x008000     ├──────────────────┤ 0x008000
> │ partition table  │              │ partition table  │
> ├──────────────────┤ 0x009000     ├──────────────────┤ 0x009000
> │ nvs              │              │ nvs              │
> ├──────────────────┤ 0x00E000     ├──────────────────┤ 0x00E000
> │                  │              │ otadata          │ ← OTA 전환 정보
> ├──────────────────┤ 0x010000     ├──────────────────┤ 0x010000
> │ factory (app)    │ ← 단일 앱   │ ota_0 (app)      │ ← 현재 펌웨어
> │                  │    OTA 불가  ├──────────────────┤ 0x1F0000
> │                  │              │ ota_1 (app)      │ ← 새 펌웨어
> ├──────────────────┤              ├──────────────────┤ 0x3D0000
> │ spiffs           │              │ spiffs           │
> └──────────────────┘              └──────────────────┘
> → partitions.csv를 수정해야 OTA 가능.
> ```
>
> ```
> # ESP32-S3 partitions.csv (OTA 지원)
> # Name,    Type, SubType, Offset,   Size
> nvs,       data, nvs,     0x9000,   0x5000
> otadata,   data, ota,     0xe000,   0x2000
> ota_0,     app,  ota_0,   0x10000,  0x1E0000  # ~1.9MB
> ota_1,     app,  ota_1,   0x1F0000, 0x1E0000  # ~1.9MB
> spiffs,    data, spiffs,  0x3D0000, 0x30000
> ```

**UART OTA 프로토콜:**

```
RTL → S3: @ota,start,184320\n          (펌웨어 크기)
RTL → S3: @ota,data,<base64 1KB>\n     (청크, ~10KB/s at 115200)
RTL → S3: @ota,data,<base64 1KB>\n
...
S3 → RTL: @ota,ack,92160\n             (수신 확인, 현재 offset)
...
RTL → S3: @ota,end,<md5>\n             (완료 + MD5 체크섬)
S3 → RTL: @ota,ok\n                    (검증 성공, 재부팅 예정)
```

**이 단계의 특징:**
- USB 없이 완전 무선 업데이트 가능
- 현장에서 DeepCoConnector로 펌웨어 관리
- UART 전송이 느림 (115200bps, 200KB에 ~25초) → 단계 3에서 개선
- OTA 실패 시 롤백 로직 필요

---

#### 단계 3: SPI 고속 OTA 추가 (전송 채널 옵션 — 선택)

> 단계 2의 S3 OTA 전송 채널에 SPI 옵션을 추가. **새로운 통신 경로를 만드는 것이 아니라,
> 이미 동작 중인 SPI 카메라 링크에 패킷 타입 하나를 추가**하는 것.

```
단계 2 시점에서 이미 동작 중인 링크:
  ┌──────┐  UART (제어/OTA)  ┌──────┐
  │  RTL │ ←──────────────→ │  S3  │
  │      │  SPI  (카메라)    │      │
  │      │ ──────────────→  │      │
  └──────┘                   └──────┘

단계 3 = RTL의 /ota_s3 핸들러에서 전송 채널만 분기:
  if (useSpiOta)
      sendViaSPI(chunk, type=OTA_DATA);   // 기존 SPI 링크 재사용
  else
      sendViaUART(chunk);                 // 기존 UART OTA (fallback)
```

**변경 내용 (단계 2 코드에 추가):**

| 변경 항목 | 위치 | 변경량 | 설명 |
|-----------|------|--------|------|
| `DCM2` 헤더에 타입 상수 추가 | S3 + RTL | 각 1줄 | `#define OTA_DATA 0x20` |
| SPI 수신부에 OTA 분기 추가 | S3 | ~20줄 | 기존 `handleSpiBlock()`에 `case OTA_DATA:` → `Update.h` 호출 |
| `/ota_s3` 전송부에 SPI 분기 추가 | RTL | ~20줄 | 기존 UART 전송 코드 옆에 `if (spi) sendSpiBlock()` 분기 |
| 전송 채널 선택 설정 | RTL | ~5줄 | `config.h`에 `#define OTA_USE_SPI true` 또는 HTTP 파라미터로 선택 |

> **핵심: 새로 만드는 게 거의 없다.**
> RTL→S3 SPI Master/Slave는 카메라용으로 이미 동작 중이고,
> S3의 `Update.h` OTA 로직은 단계 2에서 이미 구현됨.
> 단계 3은 이 둘을 연결하는 **if 분기 + 타입 상수 하나**가 본질.

**전송 속도 비교:**

| 펌웨어 크기 | UART 115200 (단계 2) | SPI 30MHz (단계 3) | 개선 |
|-------------|---------------------|-------------------|------|
| 200KB | ~25초 | < 0.1초 | 250배+ |
| 500KB | ~60초 | < 0.2초 | 300배+ |
| 1MB | ~120초 | < 0.3초 | 400배+ |

**이 단계의 특징:**
- 새 통신 경로가 아님 — 기존 SPI 카메라 링크를 그대로 재사용
- 단계 2의 UART OTA는 fallback으로 유지 (SPI 장애 시 자동 전환 가능)
- 실질 추가 코드 ~50줄 수준 (타입 상수 + if 분기 + SPI 블록 포맷팅)

---

### 3.3 구현 순서 요약

```
단계 1 (즉시 — 개발 시작 전 필수)
  └─ USB 패스스루
     ✅ S3 직접 플래시 (USB)
     ✅ RTL 패스스루 플래시 (USB → S3 → UART → RTL)
     → 구현: S3에 ~100줄 추가

단계 2 (기능 안정화 후 — 양산 전 필수)
  └─ + Wi-Fi OTA (UART 경유)
     ✅ RTL HTTP OTA (/ota)
     ✅ S3 UART OTA (/ota_s3, RTL → UART → S3)
     ✅ (선택) DeepCoConnector OTA UI
     → 구현: RTL ~300줄 + S3 ~200줄

단계 3 (선택 — 속도 필요 시)
  └─ + S3 OTA 전송 채널에 SPI 옵션 추가
     ✅ 기존 SPI 카메라 링크에 OTA 타입 추가
     ✅ RTL /ota_s3에서 UART/SPI 선택 분기
     ✅ UART OTA는 fallback으로 유지
     → 구현: ~50줄 (타입 상수 + if 분기)
```

---

### 3.4 보드 설계 요구사항 요약

**공통 (D/E 모두 동일):**

| 항목 | 내용 |
|------|------|
| 전원 | USB 5V → 3.3V 레귤레이터 → RTL + S3 공급 |
| UART | S3 TX/RX ↔ RTL Serial1 TX/RX (제어 명령, 양방향) |
| SPI | S3 SPI Slave ↔ RTL SPI Master (카메라, 단방향) |
| 공통 GND | 필수 |

**옵션별 차이:**

| 항목 | D: S3 하이브리드 | E: RTL 하이브리드 |
|------|------|------|
| USB-C 연결 | ESP32-S3 USB 핀 | RTL8720DN USB 핀 |
| GPIO 2개 방향 | S3 → RTL (CHIP_EN + BOOT) | RTL → S3 (EN + GPIO0) |
| 패스스루 코드 위치 | S3 펌웨어 | RTL 펌웨어 |

---

## 4. DevKit 테스트 환경 (커스텀 보드 제작 전)

> 커스텀 보드를 만들기 전에 **BW16 Kit (RTL)** + **ESP32-S3-CAM DevKit (S3)** 두 개의
> 개발 보드로 모든 기능을 검증합니다. devkit은 각각 USB-C가 있어 개별 플래시와
> 패스스루/OTA 테스트를 모두 수행할 수 있습니다.

### 4.1 devkit 배선도 (config.h 기준)

```
┌──────────────────────────┐              ┌──────────────────────────┐
│     BW16 Kit (RTL)       │              │   ESP32-S3-CAM DevKit    │
│     ──────────────       │              │   ──────────────────     │
│                          │              │                          │
│  [USB-C] ← RTL 직접플래시 │              │  [USB-C] ← S3 직접플래시  │
│                          │              │                          │
│  ── UART (제어 명령) ──────┤              ├──────────────────────── │
│  Serial1 TX = D4 (PB1) ──┼──────────→──┤ UART0 RX = GPIO44       │
│  Serial1 RX = D5 (PB2) ──┼──←──────────┤ UART0 TX = GPIO43       │
│                          │              │                          │
│  ── SPI (카메라 JPEG) ────┤              ├──────────────────────── │
│  SS   = D9  (PA15) ──────┼──────────→──┤ CS   = GPIO34            │
│  SCLK = D10 (PA14) ──────┼──────────→──┤ SCLK = GPIO36            │
│  MOSI = D12 (PA12) ──────┼──────────→──┤ MOSI = GPIO37            │
│  MISO = D11 (PA13) ──────┼──←──────────┤ MISO = GPIO35            │
│                          │              │                          │
│  ── GPIO (패스스루 제어) ──┤              ├──────────────────────── │
│  D6 (PA26) ──────────────┼──────────→──┤ EN   (리셋)              │
│  D7 (PA25) ──────────────┼──────────→──┤ GPIO0 (부트모드)         │
│                          │              │                          │
│  GND ────────────────────┼──────────────┤ GND                     │
└──────────────────────────┘              └──────────────────────────┘
```

### 4.2 배선 핀 매핑 요약표

| 기능 | BW16 (RTL) 핀 | 방향 | ESP32-S3-CAM 핀 | 비고 |
|------|:---:|:---:|:---:|------|
| **UART TX** | D4 (PB1) | → | GPIO44 (RX) | 제어 명령 (115200 baud) |
| **UART RX** | D5 (PB2) | ← | GPIO43 (TX) | 상태/로그 수신 |
| **SPI SS** | D9 (PA15) | → | GPIO34 | Slave Select |
| **SPI SCLK** | D10 (PA14) | → | GPIO36 | 클록 (30MHz) |
| **SPI MOSI** | D12 (PA12) | → | GPIO37 | RTL→S3 데이터 |
| **SPI MISO** | D11 (PA13) | ← | GPIO35 | S3→RTL 데이터 (카메라) |
| **S3 EN** | D6 (PA26) | → | EN | 리셋 제어 (패스스루용) |
| **S3 BOOT** | D7 (PA25) | → | GPIO0 | 부트모드 제어 (패스스루용) |
| **GND** | GND | — | GND | 공통 접지 (필수!) |

> **전원 참고:** devkit에서는 각 보드가 자체 USB로 전원을 공급받으므로
> 별도 전원 연결 불필요. 단, **GND는 반드시 연결**해야 UART/SPI 통신이 정상 동작.

### 4.3 devkit 테스트 시나리오

| # | 테스트 항목 | USB 연결 | 방법 |
|---|-----------|---------|------|
| 1 | RTL 직접 플래시 | RTL USB → PC | Arduino IDE → BW16 보드 → Upload |
| 2 | S3 직접 플래시 | S3 USB → PC | Arduino IDE → ESP32-S3 보드 → Upload |
| 3 | 양쪽 동시 디버그 | 양쪽 USB 모두 → PC | 시리얼 모니터 2개로 RTL/S3 로그 동시 확인 |
| 4 | 정상 운영 테스트 | 양쪽 USB 모두 → PC | Wi-Fi AP 접속 → WS 제어/카메라 스트리밍 검증 |
| 5 | **@passthru 테스트** | **RTL USB만** → PC (**S3 USB 분리!**) | `@passthru` → esptool이 RTL 경유 S3 플래시 |
| 6 | Wi-Fi OTA 테스트 (향후) | USB 없이 전원만 | Wi-Fi AP 접속 → HTTP `/ota`, `/ota_s3` |

### 4.4 devkit 개발 단계

```
[1단계: 기본 기능 개발] — USB 두 개 활용 (devkit 장점!)
  ├─ RTL 펌웨어 수정 → RTL USB로 직접 업로드
  ├─ S3 펌웨어 수정  → S3 USB로 직접 업로드
  └─ 양쪽 시리얼 모니터로 실시간 디버그

[2단계: 패스스루 검증] — RTL USB만 사용
  ├─ ⚠️  S3 USB 케이블 분리 (native USB와 UART 부트 충돌 방지)
  ├─ @passthru 명령으로 S3 플래시 성공 확인
  └─ 커스텀 보드(USB-C 1개)와 동일 조건 재현

[3단계: OTA 검증] — USB 없이 Wi-Fi만
  ├─ 양쪽 USB 분리 (전원만 공급, 또는 배터리)
  ├─ Wi-Fi AP 접속 → HTTP OTA 테스트
  └─ 양산 환경과 동일 조건 재현

[4단계: 커스텀 보드 설계] — devkit 검증 완료 후
  ├─ 위 핀 매핑을 커스텀 PCB 회로도에 반영
  ├─ USB-C 1개만 탑재 (RTL 연결 = 옵션 E)
  └─ devkit에서 검증된 모든 기능이 그대로 동작
```

### 4.5 devkit 주의사항

| 주의 | 설명 |
|------|------|
| **@passthru 시 S3 USB 분리** | S3의 native USB와 UART 부트가 동시 활성화되면 충돌. 패스스루 테스트 시 S3 USB 케이블을 반드시 뽑을 것. |
| **GND 공유 필수** | 두 devkit 간 GND를 연결하지 않으면 UART/SPI 신호 레벨이 불안정하여 통신 실패. |
| **SPI 배선 길이** | devkit 간 점퍼선이 길면 30MHz SPI가 불안정할 수 있음. 10cm 이내 권장. 불안정하면 `CFG_SPI_HZ`를 10MHz로 낮출 것. |
| **S3-CAM devkit GPIO0** | 일부 devkit에 GPIO0 풀업 저항/버튼이 있음. RTL이 LOW로 강제 구동하므로 보통 문제없지만, 동작 안 하면 devkit 회로도 확인. |
| **Serial1 핀 확인** | BW16의 Serial1은 variant에 의해 D4(TX)/D5(RX)로 고정. 다른 RTL devkit이면 핀 번호 확인 필요. |
