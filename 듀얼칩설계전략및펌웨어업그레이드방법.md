# 듀얼칩 설계 전략 및 펌웨어 업그레이드 방법

> DeepCo_Dual (ESP32-S3 + RTL8720DN) 보드의 USB-C 포트 연결 전략과
> 각 전략별 펌웨어 업그레이드 방법을 정리한 문서입니다.

---

## 1. 설계 전략 비교

### 1.1 전제 조건

- 보드에 **USB-C 포트 1개**만 존재
- 용도: **5V 전원 공급** + **시리얼 통신** (펌웨어 플래시 / 디버그 로그)
- 칩 간 연결: UART (제어 명령) + SPI (카메라 JPEG)
- 목표: 하나의 USB-C로 개발/디버그/OTA를 최대한 커버

---

### 1.2 옵션 A: USB-C → RTL8720DN

```
[USB-C] ── RTL8720DN ──UART──> ESP32-S3
               │                   │
          Wi-Fi AP              카메라/모터
          WS 서버               SPI Slave
          USB Serial
```

| 장점 | 단점 |
|------|------|
| 네트워크(Wi-Fi/WS) 로그를 USB에서 직접 확인 | S3 펌웨어 플래시에 RTL 경유 필요 |
| RTL 펌웨어 USB 직접 업로드 가능 | S3 저수준 디버그(crash dump) 직접 확인 불가 |
| S3 로그 중계(`@log,`) 이미 구현됨 | S3 부트모드 진입에 추가 GPIO 2개 필요 |
| `@set,channel` 등 RTL 설정 명령 바로 입력 가능 | RTL이 죽으면 USB 통신 자체 불가 (단일 실패점) |
| **현재 코드와 100% 호환** | — |

---

### 1.3 옵션 B: USB-C → ESP32-S3

```
           RTL8720DN ──UART──> ESP32-S3 ── [USB-C]
              │                    │
         Wi-Fi AP              카메라/모터
         WS 서버               USB Serial
                               SPI Slave
```

| 장점 | 단점 |
|------|------|
| S3 펌웨어를 Arduino IDE / esptool로 직접 업로드 | RTL 펌웨어 플래시에 S3 경유 필요 |
| S3 crash dump, stack trace 직접 확인 | RTL 디버그 로그를 보려면 중계 코드 추가 필요 |
| ESP32-S3 USB-OTG 활용 가능 (향후 확장) | 현재 코드 구조 리팩토링 필요 |
| 자동 부트모드 진입 (DTR/RTS) 지원 | RTL `@set,channel` 등 명령이 S3 경유 |
| 모터/카메라/LED 상태 USB에서 바로 확인 | Wi-Fi 문제 디버깅 시 RTL 로그 간접 확인 |

---

### 1.4 옵션 C: USB-C → USB 허브 → 양쪽 모두

```
[USB-C] ── USB Hub IC ┬── RTL8720DN
                      └── ESP32-S3
```

| 장점 | 단점 |
|------|------|
| 양쪽 모두 직접 플래시/디버그 가능 | USB 허브 IC 추가 (보드 복잡도/비용 증가) |
| PC에서 두 개의 COM 포트로 인식 | 보드 면적 증가, 소형화 불리 |
| 가장 유연한 개발 환경 | BOM 비용 상승 |

---

### 1.5 옵션 D: USB-C → S3 + S3가 RTL 플래시 대행 (하이브리드)

```
[USB-C] ── ESP32-S3 ──UART──> RTL8720DN
               │
          GPIO로 RTL의 BOOT/RESET 제어
```

| 장점 | 단점 |
|------|------|
| S3 플래시: USB 직접 (표준 ESP32 방식) | S3에 RTL 플래시 에이전트 코드 구현 필요 |
| RTL 플래시: S3 경유 UART 부트로더 | 개발 초기에는 RTL 별도 플래시 필요 |
| 하나의 USB-C로 양쪽 모두 플래시 가능 | RTL 디버그 로그는 S3 경유 간접 확인 |
| 보드 추가 비용 최소 (GPIO 2개만 추가) | — |
| ESP32-S3 USB-OTG 활용 가능 | — |

---

### 1.6 종합 비교표

| 기준 | A: USB→RTL | B: USB→S3 | C: 허브 | D: S3 하이브리드 |
|------|:---:|:---:|:---:|:---:|
| S3 플래시 용이성 | ▲ 어려움 | ★ 쉬움 | ★ 쉬움 | ★ 쉬움 |
| RTL 플래시 용이성 | ★ 쉬움 | ▲ 어려움 | ★ 쉬움 | ○ 중간 |
| S3 디버그 | ○ 간접 | ★ 직접 | ★ 직접 | ★ 직접 |
| RTL 디버그 | ★ 직접 | ○ 간접 | ★ 직접 | ○ 간접 |
| 현재 코드 호환 | ★ 그대로 | ▲ 리팩토링 | ○ 양쪽 수정 | ○ 일부 수정 |
| 보드 비용 | ★ 낮음 | ★ 낮음 | ▲ 높음 | ★ 낮음 |
| OTA 친화도 | ○ RTL 유리 | ○ S3 유리 | ★ 양쪽 | ★ 양쪽 |
| 향후 확장성 | ○ 보통 | ★ USB-OTG | ★ 높음 | ★ USB-OTG |
| 추가 하드웨어 | 없음 | 없음 | 허브 IC | GPIO 2개 |

> ★ 우수 / ○ 보통 / ▲ 부족

---

## 2. 옵션별 펌웨어 업그레이드 방법

### 2.1 옵션 A (USB→RTL) 의 펌웨어 업그레이드

#### RTL 펌웨어 업그레이드

| 방법 | 설명 |
|------|------|
| **USB 직접 플래시** | Arduino IDE에서 AmebaD 보드 선택 → USB-C 연결 → Upload. 가장 단순하고 표준적인 방법. |
| **Wi-Fi OTA** | RTL이 HTTP `/ota` 엔드포인트를 제공 → PC에서 `.bin` 업로드 → Flash OTA 파티션에 기록 → 재부팅. AmebaD SDK OTA 지원 활용. |

#### S3 펌웨어 업그레이드

| 방법 | 필요 조건 | 설명 |
|------|-----------|------|
| **UART 부트로더 경유** | RTL에서 S3의 GPIO0 + EN 제어 (GPIO 2개 추가 배선) | RTL이 S3를 부트모드로 전환 → UART로 esptool 프로토콜 실행 → 플래시 완료 후 정상 부팅. PC에서 RTL을 "패스스루" 모드로 전환하여 esptool이 RTL의 USB-UART를 통해 S3에 직접 통신. |
| **UART OTA (S3 자체)** | S3 펌웨어에 OTA 수신 코드 내장 + OTA 파티션 | RTL이 PC에서 받은 `.bin`을 UART로 S3에 청크 전달 (`@ota,start` / `@ota,data` / `@ota,end`). S3가 `Update.h`로 OTA 파티션에 기록 → 검증 → 재부팅. 추가 배선 불필요하지만 S3 펌웨어에 OTA 코드가 있어야 함. |
| **Wi-Fi → RTL → UART → S3** | 위 UART OTA + RTL HTTP OTA 엔드포인트 | PC → Wi-Fi → RTL HTTP → UART → S3 OTA. 완전 무선. |

---

### 2.2 옵션 B (USB→S3) 의 펌웨어 업그레이드

#### S3 펌웨어 업그레이드

| 방법 | 설명 |
|------|------|
| **USB 직접 플래시** | Arduino IDE에서 ESP32-S3 보드 선택 → USB-C 연결 → Upload. 자동 부트모드 진입(DTR/RTS). 가장 단순. |
| **Wi-Fi OTA (RTL 경유)** | PC → Wi-Fi → RTL WS/HTTP → UART → S3 OTA. S3에 OTA 수신 코드 필요. |

#### RTL 펌웨어 업그레이드

| 방법 | 필요 조건 | 설명 |
|------|-----------|------|
| **S3 패스스루 모드** | S3에서 RTL의 BOOT/RESET 제어 (GPIO 2개 추가 배선) | S3가 USB↔UART를 투명하게 중계(패스스루) + RTL을 부트모드로 전환. PC의 Arduino IDE가 S3의 USB를 통해 RTL에 플래시. S3에 패스스루 모드 코드 필요. |
| **UART OTA (RTL 자체)** | RTL 펌웨어에 UART OTA 수신 코드 내장 | S3가 PC에서 받은 `.bin`을 UART로 RTL에 청크 전달. RTL이 자체 OTA 파티션에 기록 → 재부팅. |
| **Wi-Fi OTA (RTL 직접)** | RTL HTTP OTA 엔드포인트 | PC → Wi-Fi → RTL HTTP `/ota` → Flash. USB 경유 없이 네트워크만으로 가능. |

---

### 2.3 옵션 C (USB 허브) 의 펌웨어 업그레이드

| 대상 | 방법 |
|------|------|
| **RTL** | PC에서 RTL COM 포트 선택 → Arduino IDE Upload (직접) |
| **S3** | PC에서 S3 COM 포트 선택 → Arduino IDE Upload (직접) |
| **OTA** | 옵션 A/B의 OTA 방법 모두 적용 가능 |

> 가장 단순하지만 USB 허브 IC의 보드 비용/면적 증가가 단점.

---

### 2.4 옵션 D (S3 하이브리드) 의 펌웨어 업그레이드

#### S3 펌웨어 업그레이드

| 방법 | 설명 |
|------|------|
| **USB 직접 플래시** | 옵션 B와 동일. Arduino IDE → USB-C → S3 직접 업로드. |

#### RTL 펌웨어 업그레이드

| 방법 | 필요 조건 | 설명 |
|------|-----------|------|
| **S3 플래시 에이전트** | S3에서 RTL BOOT/RESET GPIO 제어 (2개 배선) | S3에 "RTL 플래시 에이전트" 모드 구현. PC에서 S3 USB로 RTL `.bin` 전송 → S3가 RTL을 부트모드로 전환 → UART로 RTL에 기록 → 완료 후 정상 부팅. |
| **S3 USB-UART 패스스루** | 동일 GPIO 배선 | S3가 USB↔Serial1(UART)를 투명 중계. PC의 AmebaD 업로드 도구가 S3를 거쳐 RTL에 직접 통신. 더 단순하지만 S3를 패스스루 모드로 전환하는 UI/명령 필요. |
| **Wi-Fi OTA** | RTL HTTP OTA 엔드포인트 | PC → Wi-Fi → RTL `/ota`. USB 경유 불필요. 양산 후 현장 업데이트에 가장 적합. |

---

## 3. 추천 설계 및 펌웨어 업그레이드 방안

### 3.1 추천 설계: 옵션 D (USB-C → S3 하이브리드)

**선택 이유:**

1. **ESP32-S3가 "메인 MCU"** — 카메라, 모터, LED 등 로봇의 핵심 기능을 담당하므로, 직접 USB 디버그가 가능해야 개발 효율이 높음
2. **S3 USB-OTG 활용** — 향후 USB 장치(조이스틱, 센서 등) 연결 가능성
3. **자동 부트모드** — ESP32-S3는 DTR/RTS로 자동 부트모드 진입 지원 → 버튼 없이 플래시 가능
4. **보드 비용 최소** — USB 허브 IC 없이 GPIO 2개만 추가하면 RTL도 플래시 가능
5. **OTA로 양쪽 모두 커버** — RTL은 Wi-Fi OTA, S3는 RTL 경유 UART OTA로 완전 무선 업데이트 가능

**필요 추가 배선 (GPIO 2개):**

```
ESP32-S3 GPIO_A ──→ RTL8720DN CHIP_EN (RESET)
ESP32-S3 GPIO_B ──→ RTL8720DN BOOT/LOG_TX (부트모드 제어)
```

---

### 3.2 펌웨어 업그레이드 방안

#### A안: USB 패스스루 (개발/프로토타입 우선)

> 단순하고 빠르게 구현 가능. 개발 단계에서 양쪽 펌웨어를 자유롭게 업로드.

```
[개발 PC]
  │
  ├─ S3 플래시: USB-C → S3 직접 (Arduino IDE, 표준 방식)
  │
  └─ RTL 플래시: USB-C → S3(패스스루 모드) → UART → RTL
                  S3가 USB↔UART를 투명 중계
                  RTL은 부트모드 (S3가 GPIO로 제어)
                  PC의 AmebaD 업로드 도구가 그대로 동작
```

**구현 내용:**

| 구현 항목 | 위치 | 난이도 | 설명 |
|-----------|------|--------|------|
| 패스스루 모드 진입 | S3 | 낮음 | `@passthru` 시리얼 명령 수신 시 USB↔UART 브릿지 모드로 전환 |
| RTL BOOT/RESET 제어 | S3 | 낮음 | GPIO로 RTL을 부트모드로 전환 후 패스스루 시작 |
| 패스스루 종료 | S3 | 낮음 | 타임아웃 또는 특수 시퀀스로 정상 모드 복귀 |

**장점:**
- Arduino IDE의 기존 업로드 방식을 양쪽 모두 그대로 사용
- OTA 코드 없이도 양쪽 펌웨어 업데이트 가능
- 구현량 적음 (S3에 패스스루 모드 100줄 내외)

**단점:**
- RTL 플래시 시 S3가 패스스루 모드로 전환되어 로봇 기능 일시 중단
- USB 케이블 연결 필요 (무선 불가)

---

#### B안: Wi-Fi OTA (양산/현장 운영 우선)

> 현장에서 USB 케이블 없이 DeepCoConnector에서 펌웨어를 무선 업데이트.

```
[DeepCoConnector / PC 브라우저]
  │
  ├─ RTL 펌웨어: PC → Wi-Fi → http://192.168.4.1/ota (RTL 직접)
  │              RTL이 HTTP로 .bin 수신 → Flash OTA 파티션 → 재부팅
  │
  └─ S3 펌웨어:  PC → Wi-Fi → http://192.168.4.1/ota_s3 (RTL 경유)
                 RTL이 HTTP로 .bin 수신 → UART로 S3에 청크 전달
                 S3가 Update.h로 OTA 파티션에 기록 → 재부팅
```

**구현 내용:**

| 구현 항목 | 위치 | 난이도 | 설명 |
|-----------|------|--------|------|
| HTTP OTA 서버 (`/ota`) | RTL | 중간 | HTTP POST로 RTL .bin 수신 → AmebaD OTA API로 Flash 기록 |
| HTTP S3 OTA 프록시 (`/ota_s3`) | RTL | 중간 | HTTP POST로 S3 .bin 수신 → UART `@ota` 프로토콜로 S3에 전달 |
| UART OTA 수신기 | S3 | 중간 | `@ota,start,size` / `@ota,data,<base64>` / `@ota,end` 처리. ESP32 `Update.h` 사용 |
| OTA 파티션 테이블 | S3 | 낮음 | `partitions.csv`에 OTA 파티션 추가 |
| OTA UI (선택) | DeepCoConnector | 낮음 | 파일 선택 → HTTP POST 전송 → 진행률 표시 |

**UART OTA 프로토콜:**

```
RTL → S3: @ota,start,184320\n          (펌웨어 크기)
RTL → S3: @ota,data,<base64 1KB>\n     (청크, ~10KB/s at 115200)
RTL → S3: @ota,data,<base64 1KB>\n
...
S3 → RTL: @ota,ack,92160\n             (수신 확인, 현재 offset)
...
RTL → S3: @ota,end,<md5>\n             (완료 + MD5 체크섬)
S3 → RTL: @ota,ok\n                    (검증 성공, 재부팅 예정)
```

**예상 전송 시간:**

| 펌웨어 크기 | UART 115200 | SPI 30MHz (향후) |
|-------------|-------------|------------------|
| 200KB | ~25초 | < 0.1초 |
| 500KB | ~60초 | < 0.2초 |
| 1MB | ~120초 | < 0.3초 |

**장점:**
- USB 케이블 없이 완전 무선 업데이트
- 현장에서 DeepCoConnector로 펌웨어 관리 가능
- 양산 후 유지보수에 최적

**단점:**
- 구현량 많음 (RTL HTTP OTA + S3 UART OTA + 프로토콜)
- UART 전송이 느림 (115200bps, 200KB에 25초)
- OTA 실패 시 롤백 로직 필요 (안전성)

---

### 3.3 추천 구현 순서

```
Phase 1 (즉시)
  └─ A안: USB 패스스루 구현
     → 개발 중 양쪽 펌웨어를 USB로 자유롭게 플래시

Phase 2 (안정화 후)
  └─ B안: Wi-Fi OTA 구현
     → RTL OTA 먼저 (HTTP /ota)
     → S3 OTA 추가 (RTL 경유 UART)
     → DeepCoConnector에 OTA UI 추가

Phase 3 (최적화, 선택)
  └─ SPI 고속 OTA
     → UART 대신 SPI 링크로 S3 펌웨어 전달 (수백 배 빠름)
```

---

### 3.4 보드 설계 요구사항 요약

| 항목 | 내용 |
|------|------|
| USB-C 포트 | ESP32-S3의 USB 핀에 연결 |
| 전원 | USB 5V → 3.3V 레귤레이터 → RTL + S3 공급 |
| S3 → RTL GPIO 2개 | RTL CHIP_EN(리셋) + RTL BOOT(부트모드) 제어용 |
| 기존 UART | S3 TX/RX ↔ RTL Serial1 TX/RX (제어 명령, 양방향) |
| 기존 SPI | S3 SPI Slave ↔ RTL SPI Master (카메라, 단방향) |
| 공통 GND | 필수 |
